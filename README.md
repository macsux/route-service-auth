## Kerberos Authentication Proxy

This project allows solving for Kerberos authentication scenarios when ticket is transmitted via HTTP Negotiate header (aka Integrated Windows Authentication, [SPNEGO](https://en.wikipedia.org/wiki/SPNEGO#:~:text=Simple%20and%20Protected%20GSSAPI%20Negotiation,the%20choice%20of%20security%20technology.&text=This%20can%20help%20organizations%20deploy%20new%20security%20mechanisms%20in%20a%20phased%20manner.)). The proxy works in both forward and reverse modes allowing for authenticating inbound requests via Kerberos, or enriching outgoing requests with Kerberos tickets. **This solution does not depend on on Active Directory joined Windows environment - it uses fully managed Kerberos implementation. It can run on Linux, Windows and does not use MIT Kerberos**

## Configuring Kerberos 

```json
{
  "Kerberos": {
    "Kdc": "35.222.32.157",
    "Realm": "ALMIREX.DC"
  }
}
```
Realm is usually your AD domain name in upper case.
Alternatively the above can be set via environmental variables:
- `KDC`
- `REALM`



## Ingress

When configured as reverse proxy, the incoming requests are matched to a specific route defined in configuration. If the route is associated with an authorization policy, it will be applied. If the user fails to supply a valid Kerberos ticket in the request, the request will end with a `401 Unauthorized` and the request will not be proxied to the destination. 

The Kerberos ticket verification implementation relies on fully managed Kerberos ticket parser provided via [Kerberos.NET](	<https://github.com/SteveSyfuhs/Kerberos.NET>) library and does not require any communication with the domain controller. **The only requirement to authenticate incoming request and establish identity of the caller from Kerberos ticket is to configure username and password associated with SPN **

### Kerberos Authentication

The proxy sets SPNEGO authentication as the default Authentication mechanism and defined a single authorization policy called "RequireAuthenticatedUser". The SPNEGO authenticator will attempt to decrypt incoming ticket with each Secret of type WindowsCredential. See Secrets managment section on how to configure. 

### Principal propagation
When the proxy successfully establishes the security principal (identity of the caller + any additional claims) from the Kerberos ticket, it can forward it to the destination service. You can configure the propagation mode with the following config:

```json
{
  "Proxy": {
    "PrincipalForwardingMode": "Jwt" // valid values: Jwt, Headers
  }
}
```



There following propagation modes are supported:

#### JWT

The proxy forwards the principal as a JWT token to the target application. The JWT token is signed with an RSA signing key. The calling application can validate the token by retrieving the signing public key that the proxy publishes via standard OpenID Connect discovery mechanism. 

![](C:\projects\route-service-auth\docs\images\jwt.jpg)

The sample payload section of the JWT sent downstream would look as following:

```json
{
  "nbf": 1623776653,
  "exp": 1623776713,
  "iss": "http://localhost:8081",
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/sid": "S-1-5-21-3483396884-3677748265-799010679-1105",
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname": "iwaclient",
  "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier": "ALMIREX\\iwaclient",
  "http://schemas.microsoft.com/ws/2008/06/identity/claims/role": [
    "Users",
    "MyGroup2",
    "MyGroup"
  ]
}
```

This mode can be enabled as following:

```json
{
  "Proxy": {
    "PrincipalForwardingMode": "Jwt",
    "SigningSecurityKeyId": "JwtSignature", // see secrets management section on how to configure 
  }
}
```

`SigningSecurityKeyId` must point to a valid RSA PEM `SecurityKey`. See secret management for details on how to configure.

Security key can be easily generated by running the following command inside util projects folder:
```
dotnet run generate-key --single-line
```

### Headers

The principal is forwarded as special headers representing the claims (user's identity and group membership). Since there is no verification of headers by the service. Your infrastructure must be able to guarantee that all the traffic reaching the app must pass through the proxy, otherwise the headers can easily be spoofed. 

```json
{
  "Proxy": {
    "PrincipalForwardingMode": "Headers",
    "RolesHttpHeaderName": "X-CF-Roles",
    "IdentityHttpHeaderName": "X-CF-Identity"
  }
}
```



## Configuring routes

Ingress routes are defined with configuration similar to the following:

```json
{
  "Proxy": {
    "DestinationHeaderName": "X-CF-Forwarded-Url",
    "Ingress": [
      {
        "ListenPort": "${PORT?8080}", // env var PORT or 8080
        "TargetUrl": "http://localhost:8081",
        "Routes": [
          {
            "Id": "JWT secured actuators",
            "Path": "/cloudfoundryapplication**"
          },
          {
            "Id": "WCF WSDLs",
            "Path": "**/*.svc?wsdl",
            "Methods": ["GET"]
          },
          {
            "Id": "favicon.ico",
            "Path": "/favicon.ico",
            "Methods": ["GET"]
          },
          {
            "Id": "Require Kerberos authentication",
            "Path": "/**",
            "PolicyName": "RequireAuthenticatedUser"
          }
        ]
      }
    ]
  }
}

```
Routes are evaluated in order they are defined until a match is found. That means if you want to whitelist some URL patterns they should be defined first. 

If `TargetUrl` is not set, the destination is selected dynamically from the value of the incoming request's header defined by `DestinationHeaderName`. This is the desired mode when configuring proxy as a Route Service on Cloud Foundry.

### AD Groups

Kerberos tickets contain AD groups the user belongs to, but they are in [SID](https://en.wikipedia.org/wiki/Security_Identifier) format, and are not sent downstream by default. If you want to make assertions on roles, you need to configure LDAP for the route service which will be used to map SIDs to their common names. When configured it will send AD groups as part of the principal propagation mechanism. Groups are loaded once and cached in memory, so no LDAP requests are made per request. The proxy will do a periodic light weight incremental query to check if AD groups configuration has changed. The associated middleware will expand full hierarchy of AD groups based on their associations (ex. if user is only assigned group called `Foo`, and `Foo` is *memberOf* group `Bar`, then principal will show that the user belong to both). 

```json
{
  "Ldap": {
    "Server": "${Kerberos:Kdc}", // defaults to kdc
    "GroupsQuery": "CN=Users,DC=almirex,DC=dc",
    "Filter":  "(objectClass=group)",
    "CredentialID": "ThisApp",
    "RefreshFrequency": "00:00:10"
  },
}
```


## Secrets management

The configuration stack allows defining credentials in single place and referencing them in configuration by ID. This allows credentials used in multiple places to be defined only once, and allows simplified injection of credentials from secure config stores. Credentials are grouped by type, but the ID must be unique across all types. See the following on example configuration:

```json
{
  "Secrets": {
    "WindowsCredentials": { // type of secret
      "ThisApp": { // global reference ID of the secret
        "UserAccount": "iwasvc@almirex.dc",
        "Password": "P@ssword"
      },
      "Caller": {
        "UserAccount": "iwaclient@almirex.dc",
        "Password": "P@ssword"
      }
    },
    "SecurityKeys": {
      "JwtSignature": {
        "Pem": "-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAx50Iu0ajRFtCe/mdKixc+nNCOzhGUeNTLaiKXxd0TBtgP+ICCZwRES5H/IsM65spA6X/ttActcm05w5n4MCvS97IXHnLsQv+tfPdMc6hhLlmSkJ+X0vEiVOEKP/XbQjKbVLjyLnWulnln722zypVBxz0Ar+DOprPQotRT9auDvcQ/zmuvTkVBj11/fOkSuqbGLAzLovtn+XzqLhzGaGGRU9PsXBRbXxQcwDK97NR+8mVguNVCERiXIyCADgSWdvE+ldx3bj7tYub+YyN5gVsxpz5OmxF6C3wRmX7Csn/72+jHqG5KnqtizOmVQsK3osdrmX76sWSWwdKfunGqV2wPQIDAQABAoIBABcsK69R6/IrhfRObehPbhvE9ZNaXQ90jFtojWesmVuccff4jLQA4hpUfRbcLYvMX16FDsJyNmMEH3QTQAvfUnpESo4xtWvAMLl+rdbyXd3CiBVm0rTNXutyPo1j5eZKdvVqAfdzW3IWrYl1xJsYFvbUbZ9EDD/paNYYxj+2dE5YO6xqOZSO9D03Ka0+iIXx9G8/8QFuLxqnHWLZhhdDf6TFSOHJ6OnefvkAEuRZEI2K1TNTJqUEVZFTVtYl4xKoli2uE0ViLw1uKLG4N/k+k+FH/RY+Rjm4ZHxxZqAX8L3kZeaPRUVJk12nt21xnfH8p0nq2zpEoeC3zYH4ZIueESECgYEA4IO//64a1i4sLClwQkx435LivGcGW6vGc/0t7QmRHC6vC03uMDBTmyEtM0hgKO76AfpZdW3eCM+50lb0+liQfJDXlpOggO5tVdcjOqbZX5VVJEj2kXcyr31fF7PNkYkLbX5kpncliOf5Lnxp0+fttWFqz+leYwYPmd0Ub4J0vV8CgYEA45tPfQfU/7aSzmSF4XB/YZKTlFgarv99LPZpppu4bQpYvdMg3HfcxK4w3t8bitAhDHY4x+iiStLILqtBtOy2ZHdarSQ5tb5ULNWpVeOyNH/BBbnkuubu7kAUg3UvAsv48bDBHdpnbRNghaujyuWRhSbz//R8lKL55zfX0CcXW+MCgYAQP5i6oVgR3h+WRp14Pt6Ul6XPKsmcAs+G/3C+ce3Nk1dZwxcU57p1RK5nwroq3Di9weeNhxkFnDr/jQmHwLccPMNNg3ufOSIyjzJegUrEDyOtT5aAqpbBeppSNdIP0VJBZ19TaNYPlXJEOf7StjtO4DEBwQrysbKZWRWsiE14kwKBgDm5UO6HxvhXaGIZ0m57ZoLrdqw/r/zD5Q47LE5J3fshjaIO4p2ndIEZIGHVuZl58XfEn9/rWwWY8ZYMbuygwB04u/F/Z3d1XsnEIl8bET4JTH3USHMyUFRyQgGY/aQ68NbzGfclRee+61LbVf4GPOLFH0rBybq0nqaKXhx3XZA7AoGAacF2CyxoXtaAkxwrfX8IGsqpEoOM7smjYjKgkWpnUWvuK7ucCQYf7BpecRS3GHFHLEWvkZS0Nw0tv7jtccbBGeN3liE9xFeJm8r7B7qSvWpxour6rP5CuBizO/UFM1A3R3/hKoeK0PLfDZyqsrQZMx8qzO/CCkcI82qoYimCGXg=\n-----END RSA PRIVATE KEY-----"
      }
    }
  },
```

When configuring on Cloud Foundry, credentials can be easily defined by creating Custom User Provided Services and binding them to the proxy. They can then be referenced by name in configuration. A tag must be specified to set the credential type

Windows credential:

```
cf cups mykeyid -p "UserAccount, Password" -t "windows-credential"
```

Security Key:

```
cf cups myrsakey -p "Pem" -t "security-key"
```



## Egress

Docs TBD

## How to build

- Install [.NET Core 5.0 SDK](<https://dotnet.microsoft.com/download>)
- Run `dotnet publish` in src directory

## Troubleshooting

- Ensure that Service principal you're using has the appropriate SPN associated with it. For apps that use user's browser as the client, set spn to `http/fqdn`, for WCF apps set to `host/fqdn`

- If testing via browser, ensure that the site is allowed to perform negotiate authentication. For IE & Chrome this is done by adding site to Trusted list in security settings. For Firefox, open up `about:config` and set fqdn in `network.negotiate-auth.trusted-uris`

- Ensure you're testing from domain joined machine

  

## Testing on Non domain joined box
Normally when using browser on domain joined machine, a Kerberos ticket will be automatically obtained by the browser from the OS and attached to the header. You can however craft a manual request with Postman. To do so, set the following headers:

- `X-CF-Forwarded-Url` - the URL of where the proxy should forward the request. This is your backend app
- `Authentication` - `Negotiate <KerberosTicketAsBase64>`

You can obtain a base64 ticket via util project. From terminal set inside `src\KerberosUtil`, run this command:

`dotnet run get-ticket --kdc ADSERVER --user myuser@domain.com --password PASSWORD --spn http/someapp.domain.io`

